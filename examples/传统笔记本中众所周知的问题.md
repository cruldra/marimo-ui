# 传统笔记本中众所周知的问题

## 选择marimo

### marimo与Jupyter有什么不同？

marimo是对Python笔记本的重新发明，它是一个可重现、交互式且可共享的Python程序，可以作为脚本执行或部署为交互式Web应用。

**一致的状态**：在marimo中，你的笔记本代码、输出和程序状态保证是一致的。运行一个单元格，marimo会通过自动运行引用其变量的单元格来做出反应。删除一个单元格，marimo会从程序内存中清除其变量，消除隐藏状态。

**内置交互性**：marimo还配备了UI元素，如滑块、数据框转换器和交互式图表，这些都与Python自动同步。与元素交互，使用它的单元格会自动以最新值重新运行。

**纯Python程序**：与Jupyter笔记本不同，marimo笔记本存储为纯Python文件，可以作为脚本执行、部署为交互式Web应用，并且可以轻松地用Git进行版本控制。

### marimo解决了什么问题？

marimo解决了笔记本在可重现性、可维护性、交互性、可重用性和可共享性方面的问题。

**可重现性**：
在Jupyter笔记本中，你看到的代码不一定与页面上的输出或程序状态匹配。如果你删除一个单元格，其变量仍留在内存中，其他单元格可能仍会引用它们；用户可以以任意顺序执行单元格。这导致了广泛的可重现性问题。一项研究分析了1000万个Jupyter笔记本，发现其中36%不可重现。

相比之下，marimo保证你的代码、输出和程序状态是一致的，消除隐藏状态并使你的笔记本可重现。marimo通过智能分析你的代码并理解单元格之间的关系，并根据需要自动重新运行单元格来实现这一点。

此外，marimo笔记本可以内联序列化包需求；marimo在临时虚拟环境中运行这些"沙盒"笔记本，使它们在包级别上可重现。

**可维护性**：
marimo笔记本存储为纯Python程序（.py文件）。这让你可以用Git对它们进行版本控制；相比之下，Jupyter笔记本存储为JSON，需要额外步骤进行版本控制。

**交互性**：
marimo笔记本配备了与Python自动同步的UI元素（如滑块、下拉菜单）；例如，拖动滑块，所有引用它的单元格都会自动以新值重新运行。这在Jupyter笔记本中很难实现。

**可重用性**：
marimo笔记本可以从命令行作为Python脚本执行（因为它们存储为.py文件）。相比之下，对于Jupyter来说，这需要额外的步骤，比如复制粘贴代码或使用外部框架。我们还让你可以将marimo笔记本中定义的符号（函数、类）导入到其他Python程序/笔记本中，这在Jupyter中不容易做到。

**可共享性**：
每个marimo笔记本都可以作为交互式Web应用，完整包含UI元素，你可以使用`marimo run`命令提供服务。这在Jupyter中没有大量额外工作是不可能的。

### marimo.ui与Jupyter widgets有什么不同？

与Jupyter widgets不同，marimo的交互元素与Python内核自动同步：无需回调、无需观察者、无需手动重新运行单元格。

## 使用marimo

### marimo是笔记本还是库？

marimo既是笔记本也是库。

- 使用在运行`marimo edit`时在浏览器中打开的编辑器创建marimo笔记本
- 在marimo笔记本中使用marimo库（`import marimo as mo`）。用`mo.md(...)`编写markdown，用`mo.ui`创建有状态的交互元素（`mo.ui.slider(...)`），等等

### marimo笔记本和marimo应用有什么区别？

marimo程序是笔记本、应用或两者兼而有之，取决于你如何使用它们。

有两种与marimo程序交互的方式：
- 用`marimo edit`作为计算笔记本打开它
- 用`marimo run`作为交互式应用运行它

所有marimo程序都从笔记本开始，因为它们是用`marimo edit`创建的。因为marimo笔记本是反应式的并且有内置的交互元素，许多可以通过简单地隐藏笔记本代码轻松制作成有用且美观的应用：这就是`marimo run`所做的。

### marimo如何知道要运行哪些单元格？

marimo读取每个单元格一次，以确定它定义了哪些全局名称以及它读取了哪些全局名称。当一个单元格运行时，marimo运行所有读取它定义的任何全局名称的其他单元格。全局名称可以指变量、类、函数或导入。

换句话说，marimo使用静态分析从你的单元格中制作数据流图。每个单元格是图中的一个节点，全局变量在其中"流动"。每当一个单元格运行时，无论是因为你改变了它的代码还是与它读取的UI元素交互，它的所有后代都会依次运行。

### marimo会减慢我的代码吗？

不，marimo不会减慢你的代码。marimo通过读取你的代码而不是运行或跟踪它来确定单元格之间的依赖关系，所以没有运行时开销。

### 如何防止自动执行运行昂贵的单元格？

反应式（自动）执行确保你的代码和输出始终同步，通过消除隐藏状态和乱序执行来提高可重现性；marimo还注意只运行保持笔记本最新所需的最小单元格集。但是当某些单元格需要很长时间运行时，担心自动执行会在你准备好运行它们之前启动昂贵的单元格是可以理解的。

以下是避免意外执行昂贵单元格的一些技巧：

- **禁用昂贵的单元格**：当单元格被禁用时，它和它的后代被阻止运行
- **将UI元素包装在表单中**
- **使用`mo.stop`有条件地停止单元格及其后代的执行**
- **用marimo的`mo.cache`装饰函数来缓存昂贵的中间计算**
- **使用`mo.persistent_cache`将变量缓存到磁盘**
- **在运行时配置中禁用自动执行**

### 如何禁用自动执行？

你可以通过笔记本运行时设置禁用自动执行。

当自动执行被禁用时，marimo仍然为你的笔记本状态提供保证，并在适当时自动将单元格标记为过时。

### 如何使用滑块和其他交互元素？

滑块等交互UI元素在`marimo.ui`中可用。

1. 将UI元素分配给全局变量（`slider = mo.ui.slider(0, 100)`）
2. 将其包含在单元格的最后表达式中以显示它（`slider`或`mo.md(f"选择一个值: {slider}")`）
3. 通过其value属性在另一个单元格中读取其当前值（`slider.value`）

当与绑定到全局变量的UI元素交互时，引用该全局变量的所有单元格都会自动运行。

### 如何为UI元素添加提交按钮？

使用`form`方法为UI元素添加提交按钮。例如：
```python
form = marimo.ui.text_area().form()
```

当包装在表单中时，文本区域的值只有在你点击提交按钮时才会发送到Python。用`form.value`访问文本区域的最后提交值。

### 如何编写markdown？

在笔记本中导入marimo（作为mo），并使用`mo.md`函数。

### 如何显示图表？

将图表包含在单元格的最后表达式中以显示它们，就像所有其他输出一样。如果你使用matplotlib，你可以显示Figure对象（用`plt.gcf()`获取当前图形）。

### 如何重启笔记本？

要清除所有程序内存并从头重启笔记本，打开右上角的笔记本菜单并点击"重启内核"。

### 为什么我的on_change/on_click处理程序没有被调用？

UI元素的`on_change`（或对于按钮，`on_click`）处理程序只有在元素绑定到全局变量时才会被调用。

### marimo如何处理类型注解？

类型注解被注册为单元格的引用，除非它们明确写成字符串。这有助于确保在运行时依赖类型注解的代码的正确性（例如，Pydantic），同时仍然提供一种方法来省略注解对数据流图的影响。

### 我可以使用什么包？

你可以使用任何Python包。marimo单元格运行任意Python代码。

### 如何在远程服务器上使用marimo？

使用SSH端口转发在远程服务器上运行marimo并从本地机器上的浏览器连接到它。确保在远程启动marimo时传递`--headless`标志：
```bash
marimo edit --headless
```

### 如何部署应用？

使用marimo CLI的run命令将笔记本作为应用提供服务：
```bash
marimo run notebook.py
```

### marimo是免费的吗？

是的！
